{"smart-accounts":[{"name":"AuthorizedTrader.ride","dir":"smart-accounts","content":"#allow trader to set orders on your account\n#this is the same as you send your api-key on common exchanges to the trader without sharing your private key or seed\n#trader is allowed to set order on certain pairs\n#order expiration time should be less then 2 minutes, as trader cannot cancel orders in current RIDE version\n#at any time accout owner can cancel\n\nlet traderPublicKey = base58'QLMkJYFXsXiLLiKCbVCZZzQQT3whz8PAPdT7w4yQjEn'\nlet ownerPublicKey = base58'4gFmmsNv1qA9Krn3pUGbZVcJQTCsXEXhZjEtszDtxMXz'\nlet amountAsset = base58'8LLpj6yQLUu37KUt3rVo1S69j2gWMbgbM6qqgt2ac1Vb'\nlet matcherPublicKey = base58'7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy'\n\n\nmatch (tx) {\n    case o:Order =>\n        let isWavesPriceAsset = !isDefined(o.assetPair.priceAsset)\n        let rightPair = (o.assetPair.amountAsset == amountAsset) && isWavesPriceAsset\n        sigVerify(o.bodyBytes, o.proofs[0], traderPublicKey)\n        && rightPair\n        && o.expiration - o.timestamp < 120*1000\n        && o.matcherPublicKey == matcherPublicKey\n    case t:SetScriptTransaction | TransferTransaction =>\n        sigVerify(t.bodyBytes, t.proofs[0], ownerPublicKey)\n    case _ =>\n        false\n }"},{"name":"Multisig.ride","dir":"smart-accounts","content":"#define public keys\nlet alicePubKey  = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM'\nlet bobPubKey    = base58'2KwU4vzdgPmKyf7q354H9kSyX9NZjNiq4qbnH2wi2VDF'\nlet cooperPubKey = base58'GbrUeGaBfmyFJjSQb9Z8uTCej5GzjXfRDVGJGrmgt5cD'\n\n#check whoever provided the valid proof\nlet aliceSigned  = if(sigVerify(tx.bodyBytes, tx.proofs[0], alicePubKey  )) then 1 else 0\nlet bobSigned    = if(sigVerify(tx.bodyBytes, tx.proofs[1], bobPubKey    )) then 1 else 0\nlet cooperSigned = if(sigVerify(tx.bodyBytes, tx.proofs[2], cooperPubKey )) then 1 else 0\n\n#sum up every valid proof to get at least 2\naliceSigned + bobSigned + cooperSigned >= 2\n"},{"name":"XmasTree.ride","dir":"smart-accounts","content":"# Contract example from tradisys.com team\n\n### Prerequisites ###\n# - balance = playersPrize + dataTransactionFee * 3 + transferTransactionFee\n# - no data required\n#####################\n\n### Player's precautions ###\n# - Smart account balance is >= playersPrize + dataTransactionFee * 2 + transferTransactionFee\n# - Data on account: playersPublicKey matches player's public key, lockedAt is approximately equal to current block height.\n############################\n\n### Normal flow ###\n# 1) Data transaction from server, data = [lockedAt, playersPublicKey]. lockedAt = height or height - 1. Transition: InitialState -> LockedState\n# 2) Data transaction from player, data = [playersChoice]. Transition: LockedState -> PlayerRevealedHisChoiceState\n# 3) Transfer transaction  from player, amount = donation\n# 4) Data transaction from server, data = [serversChoice, serversSalt]. Transition: PlayerRevealedHisChoiceState -> WinnerIsDeterminedState\n# 5) Transfer transaction, recipients = winner (playersPrize + donation). Transition: PlayerDecidedNotToSendDonationState -> <InvalidState>\n###################\n\n### Emergency flow ###\n# 1) Normal flow #1 is completed, but user hasn't done any actions in timeoutInBlocks blocks - we allow server to override\n#    playersPublicKey and lockedAt data. Transition: UserDecidedNotToPlayState -> LockedState\n# 2) Normal flow #2 is completed, but server hasn't done any actions in timeoutInBlocks * 2 blocks from lockedAt - we allow player\n#    to widthdraw all the money. Transition: ServerDecidedNotToPlayState -> <InvalidState>\n# 3) Players sent his choice (Normal Flow #2), but not his money (Normal flow #3) - we allow server to withdraw all the money.\n#    Transition: PlayerDecidedNotToSendDonationState -> <InvalidState>\n######################\n\n### Injected values ###\nlet serversPublicKey = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM'\nlet enctyptedServersChoice = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM' # keccak256(serversChoice + serversSalt)\nlet donation = 100_000_000 # waves * 100_000_000, eq. 300000000 (= 3 waves)\nlet playersPrize = 100_000_000 # waves * 100_000_000, eq. 400000000 (= 2 waves)\nlet boxesCount = 5\n#######################\n\n### Values from data ###\nlet maybeDataPlayersPublicKey = getString(tx.sender, \"playersPublicKey\")\nlet dataPlayersPublicKey = fromBase58String(extract(maybeDataPlayersPublicKey))\nlet dataLockedAt = extract(getInteger(tx.sender, \"lockedAt\"))\nlet maybeDataPlayersChoice = getInteger(tx.sender, \"playersChoice\")\nlet dataPlayersChoice = extract(maybeDataPlayersChoice)\nlet maybeDataServersChoice = getInteger(tx.sender, \"serversChoice\")\nlet dataServersChoice = extract(maybeDataServersChoice)\n########################\n\nlet timeoutInBlocks = 120\nlet dataTransactionFee = 500000 # 0.001 + 0.004 (smart account fee)\nlet transferTransactionFee = 500000 # 0.001 + 0.004 (smart account fee)\nlet serversAddress = addressFromPublicKey(serversPublicKey)\nlet playersAddress = addressFromPublicKey(dataPlayersPublicKey)\nlet accountBalance = wavesBalance(tx.sender)\n\nlet senderIsServer = sigVerify(tx.bodyBytes, tx.proofs[0], serversPublicKey)\nlet senderIsPlayer = sigVerify(tx.bodyBytes, tx.proofs[0], dataPlayersPublicKey)\n\n### States ###\n# InitialState @ no data is deployed to account\n# Balance: playersPrize + dataTransactionFee * 3 + transferTransactionFee\nlet isInitialState = !isDefined(maybeDataPlayersPublicKey) && accountBalance >= playersPrize + dataTransactionFee * 3 + transferTransactionFee\n\n# LockedState @ account is locked for a specific player by server\n# State: playersPublicKey and lockedAt in data; height <= lockedAt + timeoutInBlocks\n# Balance: donation + dataTransactionFee * 2 + massTransferTransactionFee\nlet dataIsValidForLockedState = isDefined(maybeDataPlayersPublicKey) && !isDefined(maybeDataPlayersChoice)\nlet lockedStateTimeout = height > dataLockedAt + timeoutInBlocks\nlet isLockedState = dataIsValidForLockedState && !lockedStateTimeout\n\n# UserDecidedNotToPlayState @ user didn't send a data transaction in timeoutInBlocks blocks\nlet isUserDecidedNotToPlayState = dataIsValidForLockedState && lockedStateTimeout\n\n# PlayerRevealedHisChoiceState @ player sent a data transaction with his choice (and donationted simultaneously)\n# State: playersPublicKey, lockedAt, playersChoice in data; height <= lockedAt + timeoutInBlocks * 2\n# Balance: playersPrize (playersPrize + donation is fine too) + dataTransactionFee + transferTransactionFee\nlet dataIsValidForPlayerRevealedState = isDefined(maybeDataPlayersChoice) && !isDefined(maybeDataServersChoice)\nlet playerRevealedStateTimeout = (height > dataLockedAt + timeoutInBlocks * 2) && (accountBalance >= playersPrize + donation + dataTransactionFee + transferTransactionFee)\nlet isPlayerRevealedHisChoiceState = dataIsValidForPlayerRevealedState && !playerRevealedStateTimeout\n\n# ServerDecidedNotToPlayState @ the same as PlayerRevealedHisChoiceState, but after timeoutInBlocks * from lockedAt\n# Balance: strictly >= playersPrize + donation + dataTransactionFee + transferTransactionFee, otherwise player will be able to publish data transaction w/o transfer\nlet isServerDecidedNotToPlayState = dataIsValidForPlayerRevealedState && playerRevealedStateTimeout\n\n# WinnerIsDeterminedState @ we are ready to send money to winner\n# Balance: strictly >= playersPrize + donation + transferTransactionFee\nlet isDataValidForWinnerIsDeterminedState = isDefined(maybeDataServersChoice)\nlet isBalanceValidForWinnerIsDeterminedState = accountBalance >= playersPrize + donation + transferTransactionFee\nlet isWinnerIsDeterminedState = isDataValidForWinnerIsDeterminedState && isBalanceValidForWinnerIsDeterminedState\n\n# PlayerDecidedNotToSendDonationState @ player sent data transaction with his choice, but not a transfer transaction with donation\nlet isPlayerDecidedNotToSendDonationState = isDataValidForWinnerIsDeterminedState && !isBalanceValidForWinnerIsDeterminedState\n##############\n\nmatch (tx) {\n  case dtx:DataTransaction => (\n    let payloadSize = size(dtx.data)\n    let firstPayloadName = dtx.data[0].key\n    let secondPayloadName = dtx.data[1].key\n    let firstPayloadAsInteger = extract(getInteger(dtx.data, firstPayloadName))\n    let secondPayloadAsString = extract(getString(dtx.data, secondPayloadName))\n    let dataFeeIsOk = dtx.fee == dataTransactionFee\n\n    if (isInitialState || isUserDecidedNotToPlayState) then ( # Normal flow #1, Emergency flow #1\n        let validLockedAtIsProvided = firstPayloadName == \"lockedAt\" && (firstPayloadAsInteger <= height && height - firstPayloadAsInteger <= 5)\n        let playersPublicKeyIsProvided = secondPayloadName == \"playersPublicKey\"\n        senderIsServer && dataFeeIsOk && validLockedAtIsProvided && playersPublicKeyIsProvided && payloadSize == 2\n    ) else if (isLockedState) then ( # Normal flow #2\n        let validPlayersChoiceIsProvided = firstPayloadName == \"playersChoice\" && (firstPayloadAsInteger >= 0 && firstPayloadAsInteger < boxesCount)\n        senderIsPlayer && dataFeeIsOk && validPlayersChoiceIsProvided && payloadSize == 1\n    ) else if (isPlayerRevealedHisChoiceState) then ( # Normal flow #4\n        let validServerChoiceWasProvided = firstPayloadName == \"serversChoice\" && (firstPayloadAsInteger >= 0 && firstPayloadAsInteger < boxesCount)\n        let serversSaltWasProvided = secondPayloadName == \"serversSalt\"\n        let choiceAndSaltMatchesHardcodedValue = keccak256(toBytes(toString(firstPayloadAsInteger) + secondPayloadAsString)) == enctyptedServersChoice\n\n        senderIsServer && dataFeeIsOk && validServerChoiceWasProvided && serversSaltWasProvided && choiceAndSaltMatchesHardcodedValue && payloadSize == 2\n    ) else (\n        false \n    )\n  )\n  case ttx:TransferTransaction => (\n      let transferFeeIsOk = ttx.fee == transferTransactionFee\n\n      if (isWinnerIsDeterminedState) then ( # Normal flow #5\n        let winnerAddress = if (dataServersChoice == dataPlayersChoice) then playersAddress else serversAddress\n          let prizeGoesToWinner = ttx.recipient == winnerAddress\n\n        transferFeeIsOk && prizeGoesToWinner && ttx.amount == playersPrize + donation\n      ) else if (isServerDecidedNotToPlayState) then ( # Emergency flow #2\n        let recipientIsPlayer = ttx.recipient == playersAddress\n\n        transferFeeIsOk && recipientIsPlayer && ttx.amount == playersPrize + donation\n      ) else if (isPlayerDecidedNotToSendDonationState) then ( # Emergency flow #3\n        let recipientIsServer = ttx.recipient == serversAddress\n        transferFeeIsOk && recipientIsServer && ttx.amount == playersPrize\n      ) else (\n        false\n      )\n  )\n  case _ => false\n}\n"}],"smart-assets":[{"name":"HotPotatoToken.ride","dir":"smart-assets","content":"# This is a token-game\n# When you receive this token, you have 5000 blocks to transfer it to somebody else,\n# after that 5000 blocks you will have to pay the fee more than 1 Waves to transfer it.\n# you have to pay 10 Waves as fee to burn it, you can transfer it only to an account with >10 Waves\n\nlet minimumWavesBalance = 10_00_000_000\nlet moveTimeInBlocks = 5000\nlet minimalFeeToMove = 1_0_000_000\nlet minimalFeeToBurn = 5_0_000_000\n\n\n\nmatch (tx) {\n    case t:TransferTransaction => {\n\n        # to get a height of blockchain when HotPotato was received we expect transaction id\n        # of incoming transfer transaction in the attachment\n        let txId = t.attachment\n\n        # script can check that current recipient doesnt hold HotPotato\n        # but not now :)\n\n        # let currentRecipientBalance = assetBalance(t.recipient, t.assetId)\n        let currentRecipientWavesBalance = wavesBalance(t.recipient)\n\n        # assetId equals to issue transaction id, so we can get issuer public key (and address) from the issue transaction\n        let transaction = transactionById(extract(t.assetId))\n\n        match (transaction) {\n            case issueTx:IssueTransaction => {\n                # issuer is allowed to send tokens without any additional requirements except signature and recipient Waves balance (should be >= 10)\n                let transactionByIssuer = t.senderPublicKey == issueTx.senderPublicKey\n                if (transactionByIssuer) then {\n                    if (currentRecipientWavesBalance < minimumWavesBalance) then {\n                        throw(\"Current balance is less than minimalWavesBalance\")\n                    }else {\n                        true\n                    }\n                }else if (size(t.attachment) < 32) then {\n                    throw(\"Attachment should contain transaction id \")\n                }else{\n                    # getting incoming transaction by id (from the attachment)\n                    let receiveTx = transactionById(txId)\n                    match (receiveTx) {\n                        case recTx:TransferTransaction | MassTransferTransaction => {\n                            # get the number of block when address get a potato\n                            let receivedBlockNumber = extract(transactionHeightById(recTx.id))\n                            # check that we received assets in allowed span\n                            let receivedAssetInLastNBlocks = (height - receivedBlockNumber) <= moveTimeInBlocks && t.assetId == recTx.assetId\n                            let feeMore1Waves = t.fee >= minimalFeeToMove\n                            if (!receivedAssetInLastNBlocks && !feeMore1Waves) then {\n                                throw(\"You got potato long time ago, now you have to pay 1 WAVES fee\")\n                            }else {\n                                receivedAssetInLastNBlocks || feeMore1Waves\n                            }\n                        }\n                        case _ => throw(\"Receive tx should be a transfer\")\n                    }\n                }\n            }\n            case _ => throw(\"Not issue tx\")\n        }\n    }\n    # we allow to burn a token only if fee > 5 waves\n    case burn: BurnTransaction => {\n        if (burn.fee < minimalFeeToBurn) then {\n            throw(\"You have to pay 5 WAVES to burn this token\")\n        }else{\n            true\n        }\n    }\n    # MassTransfer and SetAssetScript transactions are allowed only for issuer\n    case mass: MassTransferTransaction | SetAssetScriptTransaction => {\n        let transaction = transactionById(extract(mass.assetId))\n\n        match (transaction) {\n            case issueTx:IssueTransaction => {\n                mass.senderPublicKey == issueTx.senderPublicKey\n            }\n            case _ => throw(\"Bad issue tx type\")\n        }\n    }\n    case _ => throw(\"You only can transfer this token\")\n  }"},{"name":"Taxation.ride","dir":"smart-assets","content":"# This script allows to apply taxation models to assets\n# Token owners can transfer it only if they pay taxes to the issuer\n# The tax size is defined by token issuer in data transaction\n\nmatch (tx) {\n    # we allow only mass transfer transactions\n    # first transfer in MassTransfer should always go to the issuer\n    case mtt:MassTransferTransaction => {\n        let firstRecipient = mtt.transfers[0].recipient\n        let firstAmount = mtt.transfers[0].amount\n        let assetId = extract(mtt.assetId)\n        let issueTransaction = transactionById(assetId)\n\n        # assetId equals to issue transaction id, so we can get issuer public key (and address) from the issue transaction\n        match(issueTransaction) {\n            case issueTx: IssueTransaction => {\n                let issuerAddress = addressFromPublicKey(issueTx.senderPublicKey)\n                # to set tax amount, issuer should make a data transaction with integer value by key matching assetId\n                let taxSize = extract(getInteger(issuerAddress, toBase58String(assetId)))\n\n                firstRecipient == issuerAddress # recipient for the first transfer should be the issuer address\n                &&\n                firstAmount >= mtt.totalAmount / 100 * taxSize # tax amount can't be less than defined in data transaction\n            }\n            case _ => false\n        }\n    }\n    case _ => false\n  }"}]}